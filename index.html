<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ê°„ë‹¨í•œ ë˜ì „ í¬ë¡¤ëŸ¬</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222;
            color: #eee;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #ff6600;
            margin-bottom: 10px;
        }
        .game-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .dungeon {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            grid-template-rows: repeat(10, 40px);
            gap: 2px;
            background-color: #333;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            background-color: #444;
            border-radius: 3px;
            transition: all 0.2s;
        }
        .wall {
            background-color: #222;
        }
        .player {
            background-color: #4CAF50;
            color: white;
        }
        .monster {
            background-color: #f44336;
            color: white;
        }
        .treasure {
            background-color: #FFD700;
            color: black;
        }
        .item {
            background-color: #9575CD;
            color: white;
        }
        .exit {
            background-color: #2196F3;
            color: white;
        }
        .empty {
            background-color: #666;
        }
        .fog {
            background-color: #444;
            color: #444;
        }
        .stats {
            background-color: #333;
            padding: 20px;
            border-radius: 5px;
            min-width: 200px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .stats h2 {
            color: #4CAF50;
            margin-top: 0;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .stats div {
            margin-bottom: 10px;
        }
        .inventory {
            background-color: #333;
            padding: 20px;
            border-radius: 5px;
            min-width: 200px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }
        .inventory h2 {
            color: #9575CD;
            margin-top: 0;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .inventory-slot {
            background-color: #444;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .inventory-slot:hover {
            background-color: #555;
        }
        .inventory-slot.equipped {
            background-color: #2a5434;
            border: 1px solid #4CAF50;
        }
        .equipped-items {
            margin-bottom: 20px;
        }
        .equipped-items h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        .equipped-slot {
            background-color: #444;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 14px;
        }
        .equipped-slot.empty {
            color: #888;
            font-style: italic;
        }
        .message-log {
            background-color: #333;
            padding: 15px;
            border-radius: 5px;
            width: 100%;
            max-width: 600px;
            height: 150px;
            overflow-y: auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .message {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        .message.info {
            background-color: #444;
        }
        .message.combat {
            background-color: #541212;
        }
        .message.treasure {
            background-color: #5f4b00;
        }
        .message.item {
            background-color: #3d3051;
        }
        .message.level {
            background-color: #1a472a;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .controls-row {
            display: flex;
            gap: 10px;
        }
    </style>
</head>
<body>
    <h1>ë˜ì „ í¬ë¡¤ëŸ¬</h1>
    <div class="game-container">
        <div class="dungeon" id="dungeon"></div>
        
        <div>
            <div class="stats">
                <h2>í”Œë ˆì´ì–´ ì •ë³´</h2>
                <div>ë ˆë²¨: <span id="level">1</span></div>
                <div>ì²´ë ¥: <span id="health">20</span>/<span id="maxHealth">20</span></div>
                <div>ê³µê²©ë ¥: <span id="attack">5</span> <span id="weaponBonus"></span></div>
                <div>ë°©ì–´ë ¥: <span id="defense">1</span> <span id="armorBonus"></span></div>
                <div>ê²½í—˜ì¹˜: <span id="exp">0</span>/<span id="expNeeded">20</span></div>
                <div>ê³¨ë“œ: <span id="gold">0</span></div>
                <div>ì¸µ: <span id="floor">1</span></div>
            </div>
            
            <div class="inventory">
                <h2>ì¸ë²¤í† ë¦¬</h2>
                <div class="equipped-items">
                    <h3>ì¥ì°© ì¤‘ì¸ ì•„ì´í…œ</h3>
                    <div class="equipped-slot" id="equipped-weapon">ë¬´ê¸°: ì—†ìŒ</div>
                    <div class="equipped-slot" id="equipped-armor">ë°©ì–´êµ¬: ì—†ìŒ</div>
                </div>
                <h3>ë³´ìœ  ì•„ì´í…œ</h3>
                <div id="inventory-items"></div>
            </div>
        </div>
    </div>
    
    <div class="message-log" id="message-log"></div>
    
    <div class="controls">
    <div class="controls-row">
        <button id="up">â†‘</button>
    </div>
    <div class="controls-row">
        <button id="left">â†</button>
        <button id="down">â†“</button>
        <button id="right">â†’</button>
    </div>
    <div class="controls-row" style="margin-top: 10px;">
        <button id="save-game" style="background-color: #2196F3;">ê²Œì„ ì €ì¥</button>
        <button id="load-game" style="background-color: #FF9800;">ê²Œì„ ë¶ˆëŸ¬ì˜¤ê¸°</button>
    </div>
</div>

    <script>
        // ì•„ì´í…œ íƒ€ì… ì •ì˜
        const ITEM_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            POTION: 'potion'
        };

        // ëª¬ìŠ¤í„° íƒ€ì… ì •ì˜
        const MONSTER_TYPES = {
            ZOMBIE: {
                name: 'ì¢€ë¹„',
                icon: 'Z',
                color: '#8B4513',
                baseHealth: 8,
                baseAttack: 3,
                baseDefense: 1,
                baseExp: 6,
                baseGold: 3,
                speed: 0.5,
                range: 1,
                special: 'slow'
            },
            GOBLIN: {
                name: 'ê³ ë¸”ë¦°',
                icon: 'G',
                color: '#32CD32',
                baseHealth: 4,
                baseAttack: 2,
                baseDefense: 0,
                baseExp: 4,
                baseGold: 5,
                speed: 1.5,
                range: 1,
                special: 'fast'
            },
            ARCHER: {
                name: 'ê¶ìˆ˜',
                icon: 'A',
                color: '#DAA520',
                baseHealth: 5,
                baseAttack: 4,
                baseDefense: 1,
                baseExp: 8,
                baseGold: 7,
                speed: 1,
                range: 3,
                special: 'ranged'
            },
            WIZARD: {
                name: 'ë§ˆë²•ì‚¬',
                icon: 'W',
                color: '#9932CC',
                baseHealth: 3,
                baseAttack: 6,
                baseDefense: 0,
                baseExp: 10,
                baseGold: 10,
                speed: 1,
                range: 4,
                special: 'magic'
            },
            ORC: {
                name: 'ì˜¤í¬ ì „ì‚¬',
                icon: 'O',
                color: '#B22222',
                baseHealth: 12,
                baseAttack: 5,
                baseDefense: 3,
                baseExp: 15,
                baseGold: 12,
                speed: 0.8,
                range: 1,
                special: 'strong'
            },
            BOSS: {
                name: 'ë˜ì „ ë³´ìŠ¤',
                icon: 'â˜…',
                color: '#FF4500',
                baseHealth: 30,
                baseAttack: 8,
                baseDefense: 5,
                baseExp: 50,
                baseGold: 50,
                speed: 1,
                range: 2,
                special: 'boss'
            }
        };

        // ì•„ì´í…œ ë°ì´í„°ë² ì´ìŠ¤
        const ITEMS = {
            // ë¬´ê¸°
            shortSword: {
                name: 'ë‹¨ê²€',
                type: ITEM_TYPES.WEAPON,
                attack: 2,
                price: 10,
                level: 1,
                icon: 'âš”ï¸'
            },
            longSword: {
                name: 'ì¥ê²€',
                type: ITEM_TYPES.WEAPON,
                attack: 4,
                price: 25,
                level: 2,
                icon: 'ğŸ—¡ï¸'
            },
            magicSword: {
                name: 'ë§ˆë²•ê²€',
                type: ITEM_TYPES.WEAPON,
                attack: 6,
                price: 50,
                level: 3,
                icon: 'âœ¨'
            },
            
            // ë°©ì–´êµ¬
            leatherArmor: {
                name: 'ê°€ì£½ ê°‘ì˜·',
                type: ITEM_TYPES.ARMOR,
                defense: 2,
                price: 15,
                level: 1,
                icon: 'ğŸ›¡ï¸'
            },
            chainMail: {
                name: 'ì‚¬ìŠ¬ ê°‘ì˜·',
                type: ITEM_TYPES.ARMOR,
                defense: 4,
                price: 35,
                level: 2,
                icon: 'ğŸ›¡ï¸'
            },
            plateArmor: {
                name: 'íŒê¸ˆ ê°‘ì˜·',
                type: ITEM_TYPES.ARMOR,
                defense: 6,
                price: 60,
                level: 3,
                icon: 'ğŸ›¡ï¸'
            },
            
            // í¬ì…˜
            healthPotion: {
                name: 'ì²´ë ¥ í¬ì…˜',
                type: ITEM_TYPES.POTION,
                healing: 10,
                price: 5,
                level: 1,
                icon: 'ğŸ§ª'
            },
            greaterHealthPotion: {
                name: 'ëŒ€í˜• ì²´ë ¥ í¬ì…˜',
                type: ITEM_TYPES.POTION,
                healing: 25,
                price: 15,
                level: 2,
                icon: 'ğŸ§ª'
            }
        };

        // ê²Œì„ ìƒíƒœ
        const gameState = {
            dungeon: [],
            fogOfWar: [],
            player: {
                x: 0,
                y: 0,
                level: 1,
                maxHealth: 20,
                health: 20,
                attack: 5,
                defense: 1,
                exp: 0,
                expNeeded: 20,
                gold: 0,
                inventory: [],
                equipped: {
                    weapon: null,
                    armor: null
                }
            },
            monsters: [],
            treasures: [],
            items: [],
            exitLocation: { x: 0, y: 0 },
            floor: 1,
            dungeonSize: 10
        };

        // ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
        function createItem(itemKey, x, y) {
            const itemData = ITEMS[itemKey];
            return {
                id: Math.random().toString(36).substr(2, 9),
                key: itemKey,
                name: itemData.name,
                type: itemData.type,
                x: x,
                y: y,
                ...itemData
            };
        }

        // ì¸ë²¤í† ë¦¬ì— ì•„ì´í…œ ì¶”ê°€
        function addToInventory(item) {
            gameState.player.inventory.push(item);
            updateInventoryDisplay();
        }

        // ì•„ì´í…œ ì¥ì°©
        function equipItem(item) {
            if (item.type === ITEM_TYPES.WEAPON) {
                if (gameState.player.equipped.weapon) {
                    // ê¸°ì¡´ ì¥ì°© ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ë¡œ
                    addToInventory(gameState.player.equipped.weapon);
                }
                gameState.player.equipped.weapon = item;
                addMessage(`${item.name}ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤. ê³µê²©ë ¥ +${item.attack}`, 'item');
            } else if (item.type === ITEM_TYPES.ARMOR) {
                if (gameState.player.equipped.armor) {
                    // ê¸°ì¡´ ì¥ì°© ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ë¡œ
                    addToInventory(gameState.player.equipped.armor);
                }
                gameState.player.equipped.armor = item;
                addMessage(`${item.name}ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤. ë°©ì–´ë ¥ +${item.defense}`, 'item');
            }
            
            // ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°
            const index = gameState.player.inventory.findIndex(i => i.id === item.id);
            if (index !== -1) {
                gameState.player.inventory.splice(index, 1);
            }
            
            updateInventoryDisplay();
            updateStats();
        }

        // ì•„ì´í…œ ì‚¬ìš©
        function useItem(item) {
            if (item.type === ITEM_TYPES.POTION) {
                if (gameState.player.health < gameState.player.maxHealth) {
                    const healAmount = Math.min(item.healing, gameState.player.maxHealth - gameState.player.health);
                    gameState.player.health += healAmount;
                    addMessage(`${item.name}ì„(ë¥¼) ì‚¬ìš©í•˜ì—¬ ì²´ë ¥ì„ ${healAmount} íšŒë³µí–ˆìŠµë‹ˆë‹¤.`, 'item');
                    
                    // ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°
                    const index = gameState.player.inventory.findIndex(i => i.id === item.id);
                    if (index !== -1) {
                        gameState.player.inventory.splice(index, 1);
                    }
                    
                    updateInventoryDisplay();
                    updateStats();
                } else {
                    addMessage('ì´ë¯¸ ì²´ë ¥ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.', 'info');
                }
            }
        }

        // ì¸ë²¤í† ë¦¬ í™”ë©´ ì—…ë°ì´íŠ¸
        function updateInventoryDisplay() {
            const inventoryItems = document.getElementById('inventory-items');
            inventoryItems.innerHTML = '';
            
            // ì¥ì°© ì•„ì´í…œ í‘œì‹œ
            const weaponSlot = document.getElementById('equipped-weapon');
            const armorSlot = document.getElementById('equipped-armor');
            
            if (gameState.player.equipped.weapon) {
                weaponSlot.textContent = `ë¬´ê¸°: ${gameState.player.equipped.weapon.name} (+${gameState.player.equipped.weapon.attack})`;
                weaponSlot.className = 'equipped-slot';
            } else {
                weaponSlot.textContent = 'ë¬´ê¸°: ì—†ìŒ';
                weaponSlot.className = 'equipped-slot empty';
            }
            
            if (gameState.player.equipped.armor) {
                armorSlot.textContent = `ë°©ì–´êµ¬: ${gameState.player.equipped.armor.name} (+${gameState.player.equipped.armor.defense})`;
                armorSlot.className = 'equipped-slot';
            } else {
                armorSlot.textContent = 'ë°©ì–´êµ¬: ì—†ìŒ';
                armorSlot.className = 'equipped-slot empty';
            }
            
            // ì¸ë²¤í† ë¦¬ ì•„ì´í…œ í‘œì‹œ
            gameState.player.inventory.forEach(item => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                let itemText = `${item.icon} ${item.name}`;
                if (item.type === ITEM_TYPES.WEAPON) {
                    itemText += ` (+${item.attack} ê³µê²©ë ¥)`;
                } else if (item.type === ITEM_TYPES.ARMOR) {
                    itemText += ` (+${item.defense} ë°©ì–´ë ¥)`;
                } else if (item.type === ITEM_TYPES.POTION) {
                    itemText += ` (+${item.healing} ì²´ë ¥)`;
                }
                
                slot.innerHTML = `<span>${itemText}</span>`;
                
                // í´ë¦­ ì´ë²¤íŠ¸
                slot.addEventListener('click', () => {
                    if (item.type === ITEM_TYPES.WEAPON || item.type === ITEM_TYPES.ARMOR) {
                        equipItem(item);
                    } else if (item.type === ITEM_TYPES.POTION) {
                        useItem(item);
                    }
                });
                
                inventoryItems.appendChild(slot);
            });
            
            if (gameState.player.inventory.length === 0) {
                inventoryItems.innerHTML = '<div style="color: #888; font-style: italic;">ë¹„ì–´ìˆìŒ</div>';
            }
        }

        // ë˜ì „ ìƒì„± í•¨ìˆ˜
        function generateDungeon() {
            // ë˜ì „ ì´ˆê¸°í™”
            gameState.dungeon = Array(gameState.dungeonSize).fill().map(() => Array(gameState.dungeonSize).fill('wall'));
            gameState.fogOfWar = Array(gameState.dungeonSize).fill().map(() => Array(gameState.dungeonSize).fill(true));
            gameState.monsters = [];
            gameState.treasures = [];
            gameState.items = [];
            
            // ë˜ì „ ë ˆì´ì•„ì›ƒ ìƒì„± (ê°„ë‹¨í•œ ëœë¤ ë£¸ ìƒì„±)
            const rooms = [];
            const roomCount = 3 + Math.floor(Math.random() * 3); // 3-5ê°œì˜ ë°©
            
            for (let i = 0; i < roomCount; i++) {
                const roomWidth = 3 + Math.floor(Math.random() * 3);
                const roomHeight = 3 + Math.floor(Math.random() * 3);
                const roomX = 1 + Math.floor(Math.random() * (gameState.dungeonSize - roomWidth - 2));
                const roomY = 1 + Math.floor(Math.random() * (gameState.dungeonSize - roomHeight - 2));
                
                rooms.push({ x: roomX, y: roomY, width: roomWidth, height: roomHeight });
                
                // ë°© ì•ˆì„ ë¹ˆ ê³µê°„ìœ¼ë¡œ ì±„ìš°ê¸°
                for (let y = roomY; y < roomY + roomHeight; y++) {
                    for (let x = roomX; x < roomX + roomWidth; x++) {
                        gameState.dungeon[y][x] = 'empty';
                    }
                }
            }
            
            // ë°©ë“¤ì„ ì—°ê²°í•˜ëŠ” ë³µë„ ìƒì„±
            for (let i = 0; i < rooms.length - 1; i++) {
                const room1 = rooms[i];
                const room2 = rooms[i + 1];
                
                // ë°©ì˜ ì¤‘ì‹¬ ì¢Œí‘œ
                const x1 = Math.floor(room1.x + room1.width / 2);
                const y1 = Math.floor(room1.y + room1.height / 2);
                const x2 = Math.floor(room2.x + room2.width / 2);
                const y2 = Math.floor(room2.y + room2.height / 2);
                
                // ìˆ˜í‰ ë³µë„
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                for (let x = minX; x <= maxX; x++) {
                    gameState.dungeon[y1][x] = 'empty';
                }
                
                // ìˆ˜ì§ ë³µë„
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                for (let y = minY; y <= maxY; y++) {
                    gameState.dungeon[y][x2] = 'empty';
                }
            }
            
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì„¤ì • (ì²« ë²ˆì§¸ ë°©ì˜ ì¤‘ì•™)
            const startRoom = rooms[0];
            gameState.player.x = Math.floor(startRoom.x + startRoom.width / 2);
            gameState.player.y = Math.floor(startRoom.y + startRoom.height / 2);
            
            // ì¶œêµ¬ ìœ„ì¹˜ ì„¤ì • (ë§ˆì§€ë§‰ ë°©ì˜ ì¤‘ì•™)
            const exitRoom = rooms[rooms.length - 1];
            gameState.exitLocation = {
                x: Math.floor(exitRoom.x + exitRoom.width / 2),
                y: Math.floor(exitRoom.y + exitRoom.height / 2)
            };
            gameState.dungeon[gameState.exitLocation.y][gameState.exitLocation.x] = 'exit';
            
            // ëª¬ìŠ¤í„° íƒ€ì…ë³„ ê°€ì¤‘ì¹˜ (ì¸µìˆ˜ì— ë”°ë¼ ë³€í™”)
            const getMonsterTypeWeights = () => {
                const weights = {
                    ZOMBIE: 10,
                    GOBLIN: 10,
                    ARCHER: Math.max(0, (gameState.floor - 1) * 5),
                    WIZARD: Math.max(0, (gameState.floor - 2) * 3),
                    ORC: Math.max(0, (gameState.floor - 3) * 4),
                };
                return weights;
            };
            
            // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ëª¬ìŠ¤í„° íƒ€ì… ì„ íƒ
            const selectMonsterType = (isSpecial = false) => {
                if (isSpecial && gameState.floor >= 5 && Math.random() < 0.2) {
                    return 'BOSS';
                }
                
                const weights = getMonsterTypeWeights();
                const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
                let random = Math.random() * totalWeight;
                
                for (const [type, weight] of Object.entries(weights)) {
                    random -= weight;
                    if (random <= 0) return type;
                }
                return 'ZOMBIE'; // ê¸°ë³¸ê°’
            };
            
            // ëª¬ìŠ¤í„° ë°°ì¹˜
            const monsterCount = 3 + Math.floor(gameState.floor * 1.5);
            let monstersPlaced = 0;
            
            while (monstersPlaced < monsterCount) {
                const x = Math.floor(Math.random() * gameState.dungeonSize);
                const y = Math.floor(Math.random() * gameState.dungeonSize);
                
                // ë¹ˆ ê³µê°„ì´ê³  í”Œë ˆì´ì–´ë‚˜ ì¶œêµ¬ê°€ ì—†ëŠ” ìœ„ì¹˜ì—ë§Œ ëª¬ìŠ¤í„° ë°°ì¹˜
                if (gameState.dungeon[y][x] === 'empty' && 
                    !(y === gameState.player.y && x === gameState.player.x) &&
                    !(y === gameState.exitLocation.y && x === gameState.exitLocation.x)) {
                    
                    gameState.dungeon[y][x] = 'monster';
                    
                    // ëª¬ìŠ¤í„° íƒ€ì… ì„ íƒ (ë§ˆì§€ë§‰ ëª¬ìŠ¤í„°ëŠ” íŠ¹ë³„í•œ ëª¬ìŠ¤í„°ì¼ ê°€ëŠ¥ì„±)
                    const isLastMonster = (monstersPlaced === monsterCount - 1);
                    const monsterType = selectMonsterType(isLastMonster);
                    const monsterTemplate = MONSTER_TYPES[monsterType];
                    const monsterLevel = Math.max(1, gameState.floor - 1 + Math.floor(Math.random() * 3));
                    
                    gameState.monsters.push({
                        x: x,
                        y: y,
                        type: monsterType,
                        name: monsterTemplate.name,
                        icon: monsterTemplate.icon,
                        color: monsterTemplate.color,
                        health: monsterTemplate.baseHealth + monsterLevel * 2,
                        maxHealth: monsterTemplate.baseHealth + monsterLevel * 2,
                        attack: monsterTemplate.baseAttack + monsterLevel,
                        defense: monsterTemplate.baseDefense + Math.floor(monsterLevel / 2),
                        exp: monsterTemplate.baseExp + monsterLevel * 2,
                        gold: monsterTemplate.baseGold + Math.floor(monsterLevel * 2 + Math.random() * 5),
                        speed: monsterTemplate.speed,
                        range: monsterTemplate.range,
                        special: monsterTemplate.special,
                        lootChance: 0.3 + gameState.floor * 0.05,
                        hasActed: false // í„´ í–‰ë™ ì—¬ë¶€
                    });
                    
                    monstersPlaced++;
                }
            }
            
            // ë³´ë¬¼ ë°°ì¹˜
            const treasureCount = 2 + Math.floor(Math.random() * 3);
            let treasuresPlaced = 0;
            
            while (treasuresPlaced < treasureCount) {
                const x = Math.floor(Math.random() * gameState.dungeonSize);
                const y = Math.floor(Math.random() * gameState.dungeonSize);
                
                // ë¹ˆ ê³µê°„ì´ê³  í”Œë ˆì´ì–´, ëª¬ìŠ¤í„°, ì¶œêµ¬ê°€ ì—†ëŠ” ìœ„ì¹˜ì—ë§Œ ë³´ë¬¼ ë°°ì¹˜
                if (gameState.dungeon[y][x] === 'empty' && 
                    !(y === gameState.player.y && x === gameState.player.x) &&
                    !(y === gameState.exitLocation.y && x === gameState.exitLocation.x) &&
                    !gameState.monsters.some(m => m.x === x && m.y === y)) {
                    
                    gameState.dungeon[y][x] = 'treasure';
                    
                    const treasureValue = Math.floor((gameState.floor * 5) + (Math.random() * gameState.floor * 5));
                    gameState.treasures.push({
                        x: x,
                        y: y,
                        gold: treasureValue
                    });
                    
                    treasuresPlaced++;
                }
            }
            
            // ì•„ì´í…œ ë°°ì¹˜
            const itemCount = 1 + Math.floor(Math.random() * (1 + gameState.floor * 0.5));
            let itemsPlaced = 0;
            
            while (itemsPlaced < itemCount) {
                const x = Math.floor(Math.random() * gameState.dungeonSize);
                const y = Math.floor(Math.random() * gameState.dungeonSize);
                
                // ë¹ˆ ê³µê°„ì´ê³  ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ê°€ ì—†ëŠ” ìœ„ì¹˜ì—ë§Œ ì•„ì´í…œ ë°°ì¹˜
                if (gameState.dungeon[y][x] === 'empty' && 
                    !(y === gameState.player.y && x === gameState.player.x) &&
                    !(y === gameState.exitLocation.y && x === gameState.exitLocation.x) &&
                    !gameState.monsters.some(m => m.x === x && m.y === y) &&
                    !gameState.treasures.some(t => t.x === x && t.y === y)) {
                    
                    gameState.dungeon[y][x] = 'item';
                    
                    // ëœë¤ ì•„ì´í…œ ì„ íƒ
                    const itemKeys = Object.keys(ITEMS);
                    const availableItems = itemKeys.filter(key => 
                        ITEMS[key].level <= Math.ceil(gameState.floor / 2)
                    );
                    const randomItemKey = availableItems[Math.floor(Math.random() * availableItems.length)];
                    
                    const item = createItem(randomItemKey, x, y);
                    gameState.items.push(item);
                    
                    itemsPlaced++;
                }
            }
            
            // í”Œë ˆì´ì–´ ì£¼ë³€ì˜ ì‹œì•¼ ì—…ë°ì´íŠ¸
            updateFogOfWar();
            renderDungeon();
            updateStats();
            updateInventoryDisplay();
            addMessage("ìƒˆë¡œìš´ ë˜ì „ì— ë“¤ì–´ì™”ìŠµë‹ˆë‹¤. ì¶œêµ¬ë¥¼ ì°¾ìœ¼ì„¸ìš”!", "info");
        }
        
        // ë˜ì „ ë Œë”ë§
        function renderDungeon() {
            const dungeonElement = document.getElementById('dungeon');
            dungeonElement.innerHTML = '';
            
            for (let y = 0; y < gameState.dungeonSize; y++) {
                for (let x = 0; x < gameState.dungeonSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // ì‹œì•¼ì— ê°€ë ¤ì§„ ì˜ì—­
                    if (gameState.fogOfWar[y][x]) {
                        cell.classList.add('fog');
                    } else {
                        // í”Œë ˆì´ì–´ ìœ„ì¹˜
                        if (x === gameState.player.x && y === gameState.player.y) {
                            cell.classList.add('player');
                            cell.textContent = '@';
                        } else {
                            // ë‹¤ë¥¸ ë˜ì „ ìš”ì†Œë“¤
                            const cellType = gameState.dungeon[y][x];
                            cell.classList.add(cellType);
                            
                            switch (cellType) {
                                case 'wall':
                                    cell.textContent = '#';
                                    break;
                                case 'monster':
                                    // ëª¬ìŠ¤í„° íƒ€ì…ì— ë”°ë¥¸ ì•„ì´ì½˜ê³¼ ìƒ‰ìƒ
                                    const monster = gameState.monsters.find(m => m.x === x && m.y === y);
                                    if (monster) {
                                        cell.textContent = monster.icon;
                                        cell.style.color = monster.color;
                                    } else {
                                        cell.textContent = 'M';
                                    }
                                    break;
                                case 'treasure':
                                    cell.textContent = 'T';
                                    break;
                                case 'item':
                                    cell.textContent = 'I';
                                    break;
                                case 'exit':
                                    cell.textContent = 'E';
                                    break;
                                default:
                                    cell.textContent = '.';
                            }
                        }
                    }
                    
                    dungeonElement.appendChild(cell);
                }
            }
        }
        
        // ì‹œì•¼ ì—…ë°ì´íŠ¸
        function updateFogOfWar() {
            const viewRange = 2;
            const { x, y } = gameState.player;
            
            for (let dy = -viewRange; dy <= viewRange; dy++) {
                for (let dx = -viewRange; dx <= viewRange; dx++) {
                    const newY = y + dy;
                    const newX = x + dx;
                    
                    if (newY >= 0 && newY < gameState.dungeonSize && 
                        newX >= 0 && newX < gameState.dungeonSize) {
                        gameState.fogOfWar[newY][newX] = false;
                    }
                }
            }
        }
        
        // ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
        function getDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        // ì‹œì•¼ ì²´í¬ í•¨ìˆ˜
        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            let x = x1;
            let y = y1;

            while (x !== x2 || y !== y2) {
                if (x !== x1 || y !== y1) {
                    if (gameState.dungeon[y][x] === 'wall') {
                        return false;
                    }
                }
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
            return true;
        }

        // ëª¬ìŠ¤í„° ê³µê²© í•¨ìˆ˜
        function monsterAttack(monster) {
            const distance = getDistance(monster.x, monster.y, gameState.player.x, gameState.player.y);
            
            // ì‚¬ê±°ë¦¬ ë‚´ì— ìˆê³  ì‹œì•¼ê°€ í™•ë³´ë˜ë©´ ê³µê²©
            if (distance <= monster.range && hasLineOfSight(monster.x, monster.y, gameState.player.x, gameState.player.y)) {
                let totalDefense = gameState.player.defense;
                if (gameState.player.equipped.armor) {
                    totalDefense += gameState.player.equipped.armor.defense;
                }
                
                const damage = Math.max(1, monster.attack - totalDefense);
                gameState.player.health -= damage;
                
                let attackType = monster.special === 'magic' ? 'ë§ˆë²• ê³µê²©' : 
                               monster.special === 'ranged' ? 'ì›ê±°ë¦¬ ê³µê²©' :
                               'ê³µê²©';
                
                addMessage(`${monster.name}ì´(ê°€) ${attackType}ìœ¼ë¡œ ${damage}ì˜ í”¼í•´ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, "combat");
                
                // í”Œë ˆì´ì–´ ì‚¬ë§ ì²´í¬
                if (gameState.player.health <= 0) {
                    handlePlayerDeath();
                    return true;
                }
            }
            return false;
        }

        // ëª¬ìŠ¤í„° ì´ë™ í•¨ìˆ˜
        function moveMonster(monster) {
            if (monster.hasActed) return;
            
            const distance = getDistance(monster.x, monster.y, gameState.player.x, gameState.player.y);
            
            // ê³µê²© ë²”ìœ„ ë‚´ë©´ ê³µê²©
            if (distance <= monster.range && hasLineOfSight(monster.x, monster.y, gameState.player.x, gameState.player.y)) {
                monsterAttack(monster);
                monster.hasActed = true;
                return;
            }
            
            // í”Œë ˆì´ì–´ë¥¼ ì¶”ì  (ì‹œì•¼ ë²”ìœ„ ë‚´ì—ì„œë§Œ)
            if (distance <= 5 && hasLineOfSight(monster.x, monster.y, gameState.player.x, gameState.player.y)) {
                const dx = Math.sign(gameState.player.x - monster.x);
                const dy = Math.sign(gameState.player.y - monster.y);
                
                let newX = monster.x;
                let newY = monster.y;
                
                // ëŒ€ê°ì„  ì´ë™ë³´ë‹¤ ì§ì„  ì´ë™ ìš°ì„ 
                if (Math.random() < 0.5) {
                    if (dx !== 0) newX += dx;
                    else if (dy !== 0) newY += dy;
                } else {
                    if (dy !== 0) newY += dy;
                    else if (dx !== 0) newX += dx;
                }
                
                // ì´ë™ ê°€ëŠ¥í•œì§€ ì²´í¬
                if (newX >= 0 && newX < gameState.dungeonSize && 
                    newY >= 0 && newY < gameState.dungeonSize &&
                    gameState.dungeon[newY][newX] === 'empty' &&
                    !(newX === gameState.player.x && newY === gameState.player.y) &&
                    !gameState.monsters.some(m => m.x === newX && m.y === newY)) {
                    
                    // ê¸°ì¡´ ìœ„ì¹˜ë¥¼ ë¹ˆ ê³µê°„ìœ¼ë¡œ
                    gameState.dungeon[monster.y][monster.x] = 'empty';
                    
                    // ìƒˆ ìœ„ì¹˜ë¡œ ì´ë™
                    monster.x = newX;
                    monster.y = newY;
                    gameState.dungeon[newY][newX] = 'monster';
                }
            }
            
            monster.hasActed = true;
        }

        // í”Œë ˆì´ì–´ ì´ë™
        function movePlayer(dx, dy) {
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            // ë§µ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
            if (newX < 0 || newX >= gameState.dungeonSize || newY < 0 || newY >= gameState.dungeonSize) {
                return;
            }
            
            const targetCell = gameState.dungeon[newY][newX];
            
            // ë²½ì€ í†µê³¼í•  ìˆ˜ ì—†ìŒ
            if (targetCell === 'wall') {
                return;
            }
            
            // ëª¬ìŠ¤í„°ì™€ ì „íˆ¬
            if (targetCell === 'monster') {
                // ëª¬ìŠ¤í„° ì°¾ê¸°
                const monsterIndex = gameState.monsters.findIndex(m => m.x === newX && m.y === newY);
                if (monsterIndex !== -1) {
                    const monster = gameState.monsters[monsterIndex];
                    
                    // ì „íˆ¬ ë¡œì§ - ì¥ë¹„ ë³´ë„ˆìŠ¤ ì ìš©
                    let totalAttack = gameState.player.attack;
                    if (gameState.player.equipped.weapon) {
                        totalAttack += gameState.player.equipped.weapon.attack;
                    }
                    
                    const playerDamage = Math.max(1, totalAttack - monster.defense);
                    monster.health -= playerDamage;
                    
                    addMessage(`${monster.name}ì—ê²Œ ${playerDamage}ì˜ í”¼í•´ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`, "combat");
                    
                    // ëª¬ìŠ¤í„°ê°€ ì£½ì—ˆëŠ”ì§€ í™•ì¸
                    if (monster.health <= 0) {
                        addMessage(`${monster.name}ì„(ë¥¼) ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤! ${monster.exp} ê²½í—˜ì¹˜ì™€ ${monster.gold} ê³¨ë“œë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`, "combat");
                        
                        // ê²½í—˜ì¹˜ì™€ ê³¨ë“œ íšë“
                        gameState.player.exp += monster.exp;
                        gameState.player.gold += monster.gold;
                        
                        // ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ íŠ¹ë³„ ë³´ìƒ
                        if (monster.special === 'boss') {
                            addMessage(`ë³´ìŠ¤ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤! ì¶”ê°€ ë³´ìƒì„ íšë“í•©ë‹ˆë‹¤!`, "level");
                            gameState.player.gold += 100;
                            
                            // ë³´ìŠ¤ëŠ” í•­ìƒ ì¢‹ì€ ì•„ì´í…œ ë“œë¡­
                            const bossItems = ['magicSword', 'plateArmor', 'greaterHealthPotion'];
                            const bossItemKey = bossItems[Math.floor(Math.random() * bossItems.length)];
                            const bossItem = createItem(bossItemKey, newX, newY);
                            gameState.items.push(bossItem);
                            gameState.dungeon[newY][newX] = 'item';
                            addMessage(`ë³´ìŠ¤ê°€ ${bossItem.name}ì„(ë¥¼) ë–¨ì–´ëœ¨ë ¸ìŠµë‹ˆë‹¤!`, "item");
                        } else if (Math.random() < monster.lootChance) {
                            // ì¼ë°˜ ì•„ì´í…œ ë“œë¡­
                            const itemKeys = Object.keys(ITEMS);
                            const availableItems = itemKeys.filter(key => 
                                ITEMS[key].level <= Math.ceil(gameState.floor / 2 + 1)
                            );
                            const randomItemKey = availableItems[Math.floor(Math.random() * availableItems.length)];
                            
                            const droppedItem = createItem(randomItemKey, newX, newY);
                            gameState.items.push(droppedItem);
                            gameState.dungeon[newY][newX] = 'item';
                            
                            addMessage(`${monster.name}ì´(ê°€) ${droppedItem.name}ì„(ë¥¼) ë–¨ì–´ëœ¨ë ¸ìŠµë‹ˆë‹¤!`, "item");
                        } else {
                            gameState.dungeon[newY][newX] = 'empty';
                        }
                        
                        // ë ˆë²¨ì—… ì²´í¬
                        checkLevelUp();
                        
                        // ëª¬ìŠ¤í„° ì œê±°
                        gameState.monsters.splice(monsterIndex, 1);
                        
                        // í”Œë ˆì´ì–´ ì´ë™
                        if (gameState.dungeon[newY][newX] === 'empty') {
                            gameState.player.x = newX;
                            gameState.player.y = newY;
                        }
                    } else {
                        // ëª¬ìŠ¤í„° ë°˜ê²©
                        addMessage(`${monster.name}ì˜ ì²´ë ¥: ${monster.health}/${monster.maxHealth}`, "combat");
                    }
                }
            } 
            // ë³´ë¬¼ íšë“
            else if (targetCell === 'treasure') {
                const treasureIndex = gameState.treasures.findIndex(t => t.x === newX && t.y === newY);
                if (treasureIndex !== -1) {
                    const treasure = gameState.treasures[treasureIndex];
                    
                    gameState.player.gold += treasure.gold;
                    addMessage(`ë³´ë¬¼ì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤! ${treasure.gold} ê³¨ë“œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤.`, "treasure");
                    
                    // ë³´ë¬¼ ì œê±°
                    gameState.treasures.splice(treasureIndex, 1);
                    gameState.dungeon[newY][newX] = 'empty';
                    
                    // í”Œë ˆì´ì–´ ì´ë™
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                }
            }
            // ì•„ì´í…œ íšë“
            else if (targetCell === 'item') {
                const itemIndex = gameState.items.findIndex(i => i.x === newX && i.y === newY);
                if (itemIndex !== -1) {
                    const item = gameState.items[itemIndex];
                    
                    addToInventory(item);
                    addMessage(`${item.name}ì„(ë¥¼) íšë“í–ˆìŠµë‹ˆë‹¤!`, "item");
                    
                    // ì•„ì´í…œ ì œê±°
                    gameState.items.splice(itemIndex, 1);
                    gameState.dungeon[newY][newX] = 'empty';
                    
                    // í”Œë ˆì´ì–´ ì´ë™
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                }
            }
            // ì¶œêµ¬
            else if (targetCell === 'exit') {
                // ë‹¤ìŒ ì¸µìœ¼ë¡œ ì§„í–‰
                gameState.floor++;
                addMessage(`ì¶•í•˜í•©ë‹ˆë‹¤! ${gameState.floor}ì¸µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤.`, "level");
                
                // ì²´ë ¥ ì¼ë¶€ íšŒë³µ
                const healAmount = Math.floor(gameState.player.maxHealth * 0.3);
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                addMessage(`íœ´ì‹ì„ ì·¨í•´ ì²´ë ¥ì´ ${healAmount} íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.`, "info");
                
                // ìƒˆ ë˜ì „ ìƒì„±
                generateDungeon();
                return;
            }
            // ë¹ˆ ê³µê°„ ì´ë™
            else {
                gameState.player.x = newX;
                gameState.player.y = newY;
            }
            
            // í”Œë ˆì´ì–´ í„´ ì¢…ë£Œ í›„ ëª¬ìŠ¤í„°ë“¤ì˜ í„´
            processMonsterseTurn();
            
            // ì‹œì•¼ ì—…ë°ì´íŠ¸
updateFogOfWar();

// í™”ë©´ ì—…ë°ì´íŠ¸
renderDungeon();
updateStats();

// ìë™ ì €ì¥
autoSave();
        }

        // ëª¬ìŠ¤í„°ë“¤ì˜ í„´ ì²˜ë¦¬
        function processMonsterseTurn() {
            // ëª¨ë“  ëª¬ìŠ¤í„°ì˜ í–‰ë™ í”Œë˜ê·¸ ì´ˆê¸°í™”
            gameState.monsters.forEach(monster => {
                monster.hasActed = false;
            });
            
            // ì†ë„ì— ë”°ë¼ ëª¬ìŠ¤í„°ë“¤ ì •ë ¬ (ë¹ ë¥¸ ëª¬ìŠ¤í„°ë¶€í„°)
            const sortedMonsters = [...gameState.monsters].sort((a, b) => b.speed - a.speed);
            
            // ê° ëª¬ìŠ¤í„°ì˜ í–‰ë™ ì²˜ë¦¬
            sortedMonsters.forEach(monster => {
                // ì†ë„ì— ë”°ë¼ ì—¬ëŸ¬ ë²ˆ í–‰ë™ ê°€ëŠ¥
                const actionCount = Math.floor(monster.speed);
                const extraActionChance = monster.speed - actionCount;
                
                for (let i = 0; i < actionCount; i++) {
                    moveMonster(monster);
                }
                
                // ì¶”ê°€ í–‰ë™ í™•ë¥ 
                if (Math.random() < extraActionChance) {
                    moveMonster(monster);
                }
            });
        }
        
        // í”Œë ˆì´ì–´ ì‚¬ë§ ì²˜ë¦¬
        function handlePlayerDeath() {
            addMessage("ë‹¹ì‹ ì€ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤. ê²Œì„ ì˜¤ë²„!", "combat");
            // 1ì´ˆ í›„ ê²Œì„ ì¬ì‹œì‘
            setTimeout(() => {
                resetGame();
            }, 1000);
        }
        
        // ê²Œì„ ì¬ì‹œì‘
        function resetGame() {
            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
            gameState.player = {
                x: 0,
                y: 0,
                level: 1,
                maxHealth: 20,
                health: 20,
                attack: 5,
                defense: 1,
                exp: 0,
                expNeeded: 20,
                gold: 0,
                inventory: [],
                equipped: {
                    weapon: null,
                    armor: null
                }
            };
            gameState.floor = 1;
            
            // ë©”ì‹œì§€ ì´ˆê¸°í™”
            document.getElementById('message-log').innerHTML = '';
            addMessage("ê²Œì„ì„ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.", "info");
            
            // ìƒˆ ë˜ì „ ìƒì„±
            generateDungeon();
        }
        
        // ë ˆë²¨ì—… ì²´í¬
        function checkLevelUp() {
            if (gameState.player.exp >= gameState.player.expNeeded) {
                gameState.player.level++;
                gameState.player.exp -= gameState.player.expNeeded;
                gameState.player.expNeeded = Math.floor(gameState.player.expNeeded * 1.5);
                
                // ëŠ¥ë ¥ì¹˜ ì¦ê°€
                gameState.player.maxHealth += 5;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.attack += 2;
                gameState.player.defense += 1;
                
                addMessage(`ë ˆë²¨ ì—…! ì´ì œ ë‹¹ì‹ ì€ ë ˆë²¨ ${gameState.player.level}ì…ë‹ˆë‹¤.`, "level");
                updateStats();
            }
        }
        
        // ë©”ì‹œì§€ ì¶”ê°€
        function addMessage(text, type = "info") {
            const messageLog = document.getElementById('message-log');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            messageLog.appendChild(message);
            messageLog.scrollTop = messageLog.scrollHeight;
        }
        
        // ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
        function updateStats() {
            document.getElementById('level').textContent = gameState.player.level;
            document.getElementById('health').textContent = gameState.player.health;
            document.getElementById('maxHealth').textContent = gameState.player.maxHealth;
            document.getElementById('attack').textContent = gameState.player.attack;
            document.getElementById('defense').textContent = gameState.player.defense;
            document.getElementById('exp').textContent = gameState.player.exp;
            document.getElementById('expNeeded').textContent = gameState.player.expNeeded;
            document.getElementById('gold').textContent = gameState.player.gold;
            document.getElementById('floor').textContent = gameState.floor;
            
            // ì¥ë¹„ ë³´ë„ˆìŠ¤ í‘œì‹œ
            const weaponBonus = document.getElementById('weaponBonus');
            const armorBonus = document.getElementById('armorBonus');
            
            if (gameState.player.equipped.weapon) {
                weaponBonus.textContent = `(+${gameState.player.equipped.weapon.attack})`;
                weaponBonus.style.color = '#4CAF50';
            } else {
                weaponBonus.textContent = '';
            }
            
            if (gameState.player.equipped.armor) {
                armorBonus.textContent = `(+${gameState.player.equipped.armor.defense})`;
                armorBonus.style.color = '#4CAF50';
            } else {
                armorBonus.textContent = '';
            }
        }
        
        // í‚¤ë³´ë“œ ì…ë ¥ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
            }
        });
        
        // ë°©í–¥ ë²„íŠ¼ ì´ë²¤íŠ¸
document.getElementById('up').addEventListener('click', () => movePlayer(0, -1));
document.getElementById('down').addEventListener('click', () => movePlayer(0, 1));
document.getElementById('left').addEventListener('click', () => movePlayer(-1, 0));
document.getElementById('right').addEventListener('click', () => movePlayer(1, 0));

// ê²Œì„ ì €ì¥ í•¨ìˆ˜
function saveGame() {
    // ê¹Šì€ ë³µì‚¬ë¥¼ í†µí•´ ìˆœí™˜ ì°¸ì¡° ë¬¸ì œ í•´ê²°
    const stateToCopy = JSON.parse(JSON.stringify(gameState));
    
    // localStorageì— ì €ì¥
    localStorage.setItem('dungeonCrawlerSave', JSON.stringify(stateToCopy));
    addMessage("ê²Œì„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", "info");
}

// ê²Œì„ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
function loadGame() {
    const savedGame = localStorage.getItem('dungeonCrawlerSave');
    
    if (savedGame) {
        // ì €ì¥ëœ ê²Œì„ ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
        const loadedState = JSON.parse(savedGame);
        
        // ê²Œì„ ìƒíƒœ ë³µì›
        gameState.dungeon = loadedState.dungeon;
        gameState.fogOfWar = loadedState.fogOfWar;
        gameState.player = loadedState.player;
        gameState.monsters = loadedState.monsters;
        gameState.treasures = loadedState.treasures;
        gameState.items = loadedState.items;
        gameState.exitLocation = loadedState.exitLocation;
        gameState.floor = loadedState.floor;
        
        // UI ì—…ë°ì´íŠ¸
        renderDungeon();
        updateStats();
        updateInventoryDisplay();
        addMessage("ì´ì „ì— ì €ì¥í•œ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.", "info");
    } else {
        addMessage("ì €ì¥ëœ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.", "info");
    }
}

// ìë™ ì €ì¥ í•¨ìˆ˜
function autoSave() {
    saveGame();
}

// ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
document.getElementById('save-game').addEventListener('click', saveGame);
document.getElementById('load-game').addEventListener('click', loadGame);

// ê²Œì„ ì´ˆê¸°í™”
generateDungeon();
    </script>
</body>
</html>